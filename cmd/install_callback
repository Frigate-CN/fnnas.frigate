#!/bin/bash

### This script is called after the user installs the application.

# 设置基础目录变量
CONFIG_PATH="${TRIM_PKGETC}/config.yaml"

# 检查配置文件是否存在
if [ -f "$CONFIG_PATH" ]; then
  echo "配置文件已存在: $CONFIG_PATH。不进行任何操作。"
  exit 0
fi

# 创建目录（如果不存在）
mkdir -p "${TRIM_PKGETC}"

# 基础配置内容
cat <<EOF > "${CONFIG_PATH}"
# YAML格式的配置文件需要严格遵守缩进对齐，建议先阅读以下教程再进行修改
# https://www.runoob.com/w3cnote/yaml-intro.html

# 完整的配置文件参考可见以下文档
# 警告：请不要直接把完整配置文件复制过来！请只需要设置需要的值
# https://docs.frigate-cn.video/configuration/reference

# 有任何配置文件的疑问，请优先阅读我们的文档，文档顶部有搜索框，善用搜索

mqtt:
  enabled: false

auth:
  reset_admin_password: false #如果忘记密码，可以通过该选项重置密码，并打印在日志中
  
# 检测的目标/物体
objects:
  track:
    # 此处请参考文档来配置需要检测的目标/物体
    # https://docs.frigate-cn.video/configuration/objects
    - person # 人
    - cat # 猫
    - dog # 狗
    - car # 车

# 录制
# 支持全部保存、只保存画面变动的片段与只保存明确检测到目标的片段，更多信息请参考下方文档
# https://docs.frigate-cn.video/configuration/record#common-recording-configurations
record:
  enabled: true # 启动录制
  preview:
    quality: very_high
  # 核查项将分为警报（alerts）和检测（detections）
  # 他们分别对应不同严重程度的视频片段
  # 例如你可以设置进入大门区域的人视作“警报”，而在附近过道行走的视作“检测”
  # 能让你更专注重要的录制
  # https://docs.frigate-cn.video/configuration/review
  retain: # 所有原始录制保留 
    days: 3
    mode: all # 将在3天期间保存所有的录制视频，包括没有画面变动或没有检测到物体/目标的视频
  alerts: # 核查警报类型录制
    retain:
      days: 10
      mode: motion # 将在最上面的3天后，仅保存画面有变动且属于核查中"警报"的视频10天
  detections: # 核查检测类型录制
    retain:
      days: 7
      mode: motion # 将在最上面的3天后，仅保存画面有变动且属于核查中"检测"的视频7天

snapshots:
  enabled: true
  timestamp: true
  bounding_box: true
  retain:
    default: 10
  quality: 95

# 添加摄像头
# https://docs.frigate-cn.video/configuration/cameras
# 注意，如果你希望能够实时监控听到声音，亦或者你觉得目前实时监控看起来不流畅
# 则需要额外设置go2rtc
# 请参阅以下文档了解相关信息
# https://docs.frigate-cn.video/configuration/live
cameras: {}

EOF

# 根据 wizard_version 和 wizard_coral 添加额外的配置

if [[ "${wizard_version}" == "-tensorrt" ]] && nvidia-smi --query-gpu=driver_version --format=csv,noheader >/dev/null 2>&1; then
  cat <<EOF >> "${CONFIG_PATH}"
# 视频编码加速
# 警告，你需要阅读以下文档进行操作，否则可能无法正常使用NVIDIA GPU进行加速：
# https://docs.frigate-cn.video/configuration/hardware_acceleration_video#nvidia-gpus
# 请务必安装NVIDIA Container Toolkit
ffmpeg:
  hwaccel_args: preset-nvidia

# 检测器
# 重要！由于没有提供默认的ONNX格式的检测模型，请参阅文档下载好对应的onnx模型后，放置在config/model_cache中，然后在model中配置该模型的文件信息
# 请务必仔细阅读以下文档，了解如何下载模型文件
# https://docs.frigate-cn.video/configuration/object_detectors#onnx

#detectors:
#  onnx_0:
#    type: onnx
EOF
elif [[ "${wizard_version}" == "-rocm" ]] && ls /dev/dri/renderD* >/dev/null 2>&1; then
  cat <<EOF >> "${CONFIG_PATH}"
# 视频编码加速
# 注意，你可能需要参考文档，添加额外的环境变量 LIBVA_DRIVER_NAME=radeonsi 后才能正常使用AMD进行视频硬件加速
# https://docs.frigate-cn.video/configuration/hardware_acceleration_video#amdati-gpus-radeon-hd-2000-and-newer-gpus-via-libva-mesa-driver
ffmpeg:
  hwaccel_args: preset-vaapi

# 检测器
# 重要！由于没有提供默认的ONNX格式的检测模型，请参阅文档下载好对应的onnx模型后，放置在config/model_cache中，然后在model中配置该模型的文件信息
# 请务必仔细阅读以下文档，了解如何下载模型文件
# 同时需要注意，部分AMD核显不一定支持rocm，也就无法进行检测器硬件加速
# https://docs.frigate-cn.video/configuration/object_detectors#onnx

#detectors:
#  onnx_0:
#    type: onnx
EOF
elif [[ "${wizard_version}" == "-rockchip" ]]; then
  cat <<EOF >> "${CONFIG_PATH}"
# 视频编码加速
ffmpeg:
  hwaccel_args: preset-rkmpp
  path: "7.0" # 如果出现编解码失败，可以尝试注释这一条

# 检测器
detectors:
  rknn:
    type: rknn
    # 如果有多核NPU（如在rk3588上），可增加此值以提高性能，例如设置为3
    num_cores: 0

model:
  # 模型名称（将自动下载）或自定义.rknn模型文件路径
  # 可选值：
  # - frigate-fp16-yolov9-t
  # - frigate-fp16-yolov9-s
  # - frigate-fp16-yolov9-m
  # - frigate-fp16-yolov9-c
  # - frigate-fp16-yolov9-e
  # 或你的yolo_model.rknn容器内完整路径
  path: frigate-fp16-yolov9-t
  model_type: yolo-generic
  width: 320 # 此处为模型支持的大小，不是检测画面的大小，请勿随意修改
  height: 320 # 此处为模型支持的大小，不是检测画面的大小，请勿随意修改
  input_tensor: nhwc
  labelmap_path: /labelmap/coco-80.txt

EOF
elif [[ "${wizard_version}" != "-tensorrt" ]] && [[ "${wizard_version}" != "-rocm" ]] && ls /dev/dri/renderD* >/dev/null 2>&1; then
  if [ -z "${wizard_coral}" ] || [ -z "$(echo ${wizard_coral} | tr -d ' ')" ]; then
    cat <<EOF >> "${CONFIG_PATH}"
# 视频编码加速
ffmpeg:
  hwaccel_args: preset-vaapi # 如果你的设备支持qsv，可以考虑更换为preset-intel-qsv-h265（注意，最后的h265根据摄像头实际编码情况调整）

# 检测器
detectors:
  ov:
    type: openvino # Intel 专用的检测器加速方案
    device: GPU

# 模型参数
model:
  width: 300 # 此处为模型支持的大小，不是检测画面的大小，请勿随意修改
  height: 300 # 此处为模型支持的大小，不是检测画面的大小，请勿随意修改
  input_tensor: nhwc
  input_pixel_format: bgr
  path: /openvino-model/ssdlite_mobilenet_v2.xml
  labelmap_path: /openvino-model/coco_91cl_bkgr.txt
EOF
  elif [[ "${wizard_coral}" == */dev/bus/usb:/dev/bus/usb* ]]; then
    cat <<EOF >> "${CONFIG_PATH}"
# 视频编码加速
ffmpeg:
  hwaccel_args: preset-vaapi # 如果你的设备支持qsv，可以考虑更换为preset-intel-qsv-h265（注意，最后的h265根据摄像头实际编码情况调整）

# 检测器
detectors:
  # USB Coral加速卡
  coral:
    type: edgetpu
    device: usb

# 模型参数
model:
  width: 300 # 此处为模型支持的大小，不是检测画面的大小，请勿随意修改
  height: 300 # 此处为模型支持的大小，不是检测画面的大小，请勿随意修改
  input_tensor: nhwc
  input_pixel_format: bgr
  path: /openvino-model/ssdlite_mobilenet_v2.xml
  labelmap_path: /openvino-model/coco_91cl_bkgr.txt
EOF
  elif [[ "${wizard_coral}" == */dev/apex_0:/dev/apex_0* ]]; then
    cat <<EOF >> "${CONFIG_PATH}"
# 视频编码加速
ffmpeg:
  hwaccel_args: preset-vaapi # 如果你的设备支持qsv，可以考虑更换为preset-intel-qsv-h265（注意，最后的h265根据摄像头实际编码情况调整）

# 检测器
detectors:
  # coral M.2加速卡
  coral:
    type: edgetpu
    device: pci

# 模型参数
model:
  width: 300 # 此处为模型支持的大小，不是检测画面的大小，请勿随意修改
  height: 300 # 此处为模型支持的大小，不是检测画面的大小，请勿随意修改
  input_tensor: nhwc
  input_pixel_format: bgr
  path: /openvino-model/ssdlite_mobilenet_v2.xml
  labelmap_path: /openvino-model/coco_91cl_bkgr.txt
EOF
  fi

fi
echo "配置文件已生成在 ${CONFIG_PATH}"

exit 0